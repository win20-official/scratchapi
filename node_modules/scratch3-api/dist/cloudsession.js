"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const ws_1 = __importDefault(require("ws"));
/**
 * ClousSession API.
 * @extends EventEmitter
 * @property {UserSession} user - UserSession that the CloudSession was created with.
 * @property {number|string} id - The id of the project that the CloudSession is connecting to.
 * @property {object} variables - Project variables.
 */
class CloudSession extends events_1.default {
    /**
     * @param user - The UserSession to create the CloudSession with.
     * @param proj - The ID of the project to connect to.
     */
    constructor(user, proj, turbowarp = false) {
        super();
        this.variables = {};
        this._variables = {};
        this.attemptedPackets = [];
        this.user = user;
        this.id = Number(proj);
        this.usetw = turbowarp;
        this.connection = new ws_1.default(`wss://${this.usetw ? "clouddata.turbowarp.org" : "clouddata.scratch.mit.edu"}/`, [], {
            headers: {
                cookie: `${this.usetw ? "" : `scratchsessionsid=${this.user.sessionId}`};`,
                origin: "https://scratch.mit.edu"
            }
        });
        let self = this;
        let handshake = this.sendHandshake.bind(this);
        let sendPacket = this.sendPacket.bind(this);
        this.connection.on("open", function () {
            handshake();
            for (let packet of self.attemptedPackets) {
                sendPacket(packet);
            }
            self.attemptedPackets = [];
            /**
             * WebSocket connection was reset.
             * @event CloudSession#reset
             */
            self.emit("reset");
        });
        this.connection.on("close", function () {
            self.connect();
        });
        let s = "";
        let handlePacket = this.handlePacket.bind(this);
        if (!this.usetw) {
            this.connection.on("message", function (c) {
                s += c;
                let p = s.split("\n");
                s = String(p.pop());
                for (let l of p) {
                    let t;
                    try {
                        t = JSON.parse(l);
                    }
                    catch (_a) {
                        console.warn(`Invalid packet:\n${l}`);
                        return;
                    }
                    handlePacket(t);
                }
            });
        }
        else {
            this.connection.on("message", function (p) {
                for (let m of p.split("\n")) {
                    let t;
                    try {
                        t = JSON.parse(m);
                    }
                    catch (_a) {
                        console.warn(`Invalid packet!`);
                        return;
                    }
                    handlePacket(t);
                }
            });
        }
    }
    handlePacket(p) {
        if (!p)
            return;
        let t;
        try {
            t = JSON.parse(p);
        }
        catch (_a) {
            t = p;
        }
        if (t.method === "set") {
            let isNew = !this.variables.hasOwnProperty(t.name);
            if (isNew) {
                this.addVariable(t.name, t.value);
                this.emit("addvariable", t.name, t.value);
            }
            this._variables[t.name] = t.value;
            /**
             * A cloud variable was set by a user.
             * @event CloudSession#set
             * @property {string} name - The name of the variable that was set.
             * @property {string} value - The value of the variable.
             */
            this.emit("set", t.name, t.value);
        }
        else {
            console.warn(`Unimplemented packet: ${t}`);
        }
    }
    sendHandshake() {
        this.send("handshake", {});
    }
    sendSet(n, v) {
        this.send("set", {
            name: n,
            value: v
        });
    }
    send(m, o = {}) {
        let t = {
            user: this.user.username,
            project_id: this.id,
            method: m
        };
        for (let op in o) {
            t[op] = o[op];
        }
        this.sendPacket(JSON.stringify(t) + "\n");
    }
    sendPacket(d) {
        if (this.connection.readyState === ws_1.default.OPEN) {
            this.connection.send(d);
        }
        else {
            this.attemptedPackets.push(d);
        }
    }
    addVariable(n, v) {
        let self = this;
        this._variables[n] = v;
        Object.defineProperty(this.variables, n, {
            get: function () {
                return self.get(n);
            },
            set: function (val) {
                return self.set(n, val);
            }
        });
    }
    /**
     * Create a new, connected CloudSession.
     * @async
     * @param {UserSession} user - The UserSession to create the CloudSession with.
     * @param {number|string} proj - The ID of the project to connect to.
     * @returns {CloudSession} A loaded CloudSession.
     */
    static create(user, proj, turbowarp) {
        return __awaiter(this, void 0, void 0, function* () {
            let s = new CloudSession(user, proj, turbowarp);
            yield s.connect();
            return s;
        });
    }
    /**
     * Connect the CloudSession to the Scratch Server.
     * @fires CloudSession#reset
     * @fires CloudSession#set
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            let connection = this.connection;
            yield new Promise(function (resolve) {
                connection.on("open", function () {
                    self.emit("open");
                    resolve();
                });
            });
        });
    }
    /**
     * End the WebSocket connection.
     */
    end() {
        if (this.connection) {
            this.connection.close();
        }
    }
    /**
     * Get the value of a variable.
     * @param {string} n - The name of the variable.
     * @returns {string} The variable's value.
     */
    get(n) {
        return this._variables[n];
    }
    /**
     * Set a cloud variable in the project.
     * @param {string} n - The name of the variable.
     * @param {number|string} v - The value to set the variable to.
     */
    set(n, v) {
        if (isNaN(Number(v)))
            console.warn("Only number values can be stored in cloud variables.");
        this._variables[n] = v;
        this.sendSet(n, v);
    }
    /**
     * Add the "☁" symbol to a name.
     * @param {string} n - The name of the variable.
     * @returns {string}
     */
    name(n) {
        return `☁ ${n}`;
    }
    /**
     * Convert a string to a sequence of numbers that can be stored in a cloud variable.
     * @param {string} [s=""] - The string to convert.
     * @returns {string} A sequence of numbers representing the input string.
     */
    numerify(str = "") {
        const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%()*+,-./\\:;=?@[]^_`{|}~\"'&<> ";
        let r = "";
        for (let l of String(str)) {
            if (chars.indexOf(l) < 0) {
                r += String(chars.length + 1);
                continue;
            }
            r +=
                chars.indexOf(l) + 1 < 10
                    ? `0${chars.indexOf(l) + 1}`
                    : `${chars.indexOf(l) + 1}`;
        }
        return `${r}00`;
    }
    /**
     * Cinvert a sequence of numbers into the represented string.
     * @param {string|number} [n=""] - The number to convert.
     * @param {number} l - The letter of the input number to start the conversion at.
     * @returns {string} The converted string.
     */
    stringify(num, startLetter = 0) {
        const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%()*+,-./\\:;=?@[]^_`{|}~\"'&<> ";
        let r = "";
        let t = String(num)
            .slice(startLetter)
            .match(/[0-9][0-9]?/g);
        for (let c of t) {
            if (c === "00") {
                return r;
            }
            if (c > chars.length) {
                continue;
            }
            r += chars[c - 1];
        }
        return r;
    }
}
exports.default = CloudSession;
